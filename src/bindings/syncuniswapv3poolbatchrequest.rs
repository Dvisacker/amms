/**

Generated by the following Solidity interface...
```solidity
interface SyncUniswapV3PoolBatchRequest {
    constructor(address[] pools);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "pools",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "nonpayable"
  }
]
```*/
#[allow(non_camel_case_types, non_snake_case, clippy::style)]
pub mod SyncUniswapV3PoolBatchRequest {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x608060405234801561000f575f80fd5b50604051610aee380380610aee83398181016040528101906100319190610562565b5f815167ffffffffffffffff81111561004d5761004c6103cc565b5b60405190808252806020026020018201604052801561008657816020015b610073610355565b81526020019060019003908161006b5790505b5090505f5b82518110156102f6575f8382815181106100a8576100a76105a9565b5b602002602001015190506100c18161032460201b60201c565b156100cc57506102eb565b6100d4610355565b5f808373ffffffffffffffffffffffffffffffffffffffff16633850c7bd6040518163ffffffff1660e01b815260040160e060405180830381865afa15801561011f573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061014391906106d8565b5050505050915091505f8473ffffffffffffffffffffffffffffffffffffffff1663f30dba93836040518263ffffffff1660e01b81526004016101869190610784565b61010060405180830381865afa1580156101a2573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906101c691906108ba565b5050505050509150508473ffffffffffffffffffffffffffffffffffffffff16631a6865026040518163ffffffff1660e01b8152600401602060405180830381865afa158015610218573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061023c919061096b565b845f01906fffffffffffffffffffffffffffffffff1690816fffffffffffffffffffffffffffffffff168152505082846020019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505081846040019060020b908160020b81525050808460600190600f0b9081600f0b81525050838787815181106102da576102d96105a9565b5b602002602001018190525050505050505b80600101905061008b565b505f816040516020016103099190610acd565b60405160208183030381529060405290506020810180590381f35b5f808273ffffffffffffffffffffffffffffffffffffffff163b0361034c5760019050610350565b5f90505b919050565b60405180608001604052805f6fffffffffffffffffffffffffffffffff1681526020015f73ffffffffffffffffffffffffffffffffffffffff1681526020015f60020b81526020015f600f0b81525090565b5f604051905090565b5f80fd5b5f80fd5b5f80fd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b610402826103bc565b810181811067ffffffffffffffff82111715610421576104206103cc565b5b80604052505050565b5f6104336103a7565b905061043f82826103f9565b919050565b5f67ffffffffffffffff82111561045e5761045d6103cc565b5b602082029050602081019050919050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f61049c82610473565b9050919050565b6104ac81610492565b81146104b6575f80fd5b50565b5f815190506104c7816104a3565b92915050565b5f6104df6104da84610444565b61042a565b905080838252602082019050602084028301858111156105025761050161046f565b5b835b8181101561052b578061051788826104b9565b845260208401935050602081019050610504565b5050509392505050565b5f82601f830112610549576105486103b8565b5b81516105598482602086016104cd565b91505092915050565b5f60208284031215610577576105766103b0565b5b5f82015167ffffffffffffffff811115610594576105936103b4565b5b6105a084828501610535565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b6105df81610473565b81146105e9575f80fd5b50565b5f815190506105fa816105d6565b92915050565b5f8160020b9050919050565b61061581610600565b811461061f575f80fd5b50565b5f815190506106308161060c565b92915050565b5f61ffff82169050919050565b61064c81610636565b8114610656575f80fd5b50565b5f8151905061066781610643565b92915050565b5f60ff82169050919050565b6106828161066d565b811461068c575f80fd5b50565b5f8151905061069d81610679565b92915050565b5f8115159050919050565b6106b7816106a3565b81146106c1575f80fd5b50565b5f815190506106d2816106ae565b92915050565b5f805f805f805f60e0888a0312156106f3576106f26103b0565b5b5f6107008a828b016105ec565b97505060206107118a828b01610622565b96505060406107228a828b01610659565b95505060606107338a828b01610659565b94505060806107448a828b01610659565b93505060a06107558a828b0161068f565b92505060c06107668a828b016106c4565b91505092959891949750929550565b61077e81610600565b82525050565b5f6020820190506107975f830184610775565b92915050565b5f6fffffffffffffffffffffffffffffffff82169050919050565b6107c18161079d565b81146107cb575f80fd5b50565b5f815190506107dc816107b8565b92915050565b5f81600f0b9050919050565b6107f7816107e2565b8114610801575f80fd5b50565b5f81519050610812816107ee565b92915050565b5f819050919050565b61082a81610818565b8114610834575f80fd5b50565b5f8151905061084581610821565b92915050565b5f8160060b9050919050565b6108608161084b565b811461086a575f80fd5b50565b5f8151905061087b81610857565b92915050565b5f63ffffffff82169050919050565b61089981610881565b81146108a3575f80fd5b50565b5f815190506108b481610890565b92915050565b5f805f805f805f80610100898b0312156108d7576108d66103b0565b5b5f6108e48b828c016107ce565b98505060206108f58b828c01610804565b97505060406109068b828c01610837565b96505060606109178b828c01610837565b95505060806109288b828c0161086d565b94505060a06109398b828c016105ec565b93505060c061094a8b828c016108a6565b92505060e061095b8b828c016106c4565b9150509295985092959890939650565b5f602082840312156109805761097f6103b0565b5b5f61098d848285016107ce565b91505092915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b6109c88161079d565b82525050565b6109d781610473565b82525050565b6109e681610600565b82525050565b6109f5816107e2565b82525050565b608082015f820151610a0f5f8501826109bf565b506020820151610a2260208501826109ce565b506040820151610a3560408501826109dd565b506060820151610a4860608501826109ec565b50505050565b5f610a5983836109fb565b60808301905092915050565b5f602082019050919050565b5f610a7b82610996565b610a8581856109a0565b9350610a90836109b0565b805f5b83811015610ac0578151610aa78882610a4e565b9750610ab283610a65565b925050600181019050610a93565b5085935050505092915050565b5f6020820190508181035f830152610ae58184610a71565b90509291505056fe
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW_\x80\xFD[P`@Qa\n\xEE8\x03\x80a\n\xEE\x839\x81\x81\x01`@R\x81\x01\x90a\x001\x91\x90a\x05bV[_\x81Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\0MWa\0La\x03\xCCV[[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\0\x86W\x81` \x01[a\0sa\x03UV[\x81R` \x01\x90`\x01\x90\x03\x90\x81a\0kW\x90P[P\x90P_[\x82Q\x81\x10\x15a\x02\xF6W_\x83\x82\x81Q\x81\x10a\0\xA8Wa\0\xA7a\x05\xA9V[[` \x02` \x01\x01Q\x90Pa\0\xC1\x81a\x03$` \x1B` \x1CV[\x15a\0\xCCWPa\x02\xEBV[a\0\xD4a\x03UV[_\x80\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c8P\xC7\xBD`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01`\xE0`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x01\x1FW=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x01C\x91\x90a\x06\xD8V[PPPPP\x91P\x91P_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\xF3\r\xBA\x93\x83`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x01\x86\x91\x90a\x07\x84V[a\x01\0`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x01\xA2W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x01\xC6\x91\x90a\x08\xBAV[PPPPPP\x91PP\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16c\x1Ahe\x02`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x02\x18W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x02<\x91\x90a\tkV[\x84_\x01\x90o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPP\x82\x84` \x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPP\x81\x84`@\x01\x90`\x02\x0B\x90\x81`\x02\x0B\x81RPP\x80\x84``\x01\x90`\x0F\x0B\x90\x81`\x0F\x0B\x81RPP\x83\x87\x87\x81Q\x81\x10a\x02\xDAWa\x02\xD9a\x05\xA9V[[` \x02` \x01\x01\x81\x90RPPPPPP[\x80`\x01\x01\x90Pa\0\x8BV[P_\x81`@Q` \x01a\x03\t\x91\x90a\n\xCDV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P` \x81\x01\x80Y\x03\x81\xF3[_\x80\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x03a\x03LW`\x01\x90Pa\x03PV[_\x90P[\x91\x90PV[`@Q\x80`\x80\x01`@R\x80_o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_`\x02\x0B\x81R` \x01_`\x0F\x0B\x81RP\x90V[_`@Q\x90P\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[a\x04\x02\x82a\x03\xBCV[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a\x04!Wa\x04 a\x03\xCCV[[\x80`@RPPPV[_a\x043a\x03\xA7V[\x90Pa\x04?\x82\x82a\x03\xF9V[\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\x04^Wa\x04]a\x03\xCCV[[` \x82\x02\x90P` \x81\x01\x90P\x91\x90PV[_\x80\xFD[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a\x04\x9C\x82a\x04sV[\x90P\x91\x90PV[a\x04\xAC\x81a\x04\x92V[\x81\x14a\x04\xB6W_\x80\xFD[PV[_\x81Q\x90Pa\x04\xC7\x81a\x04\xA3V[\x92\x91PPV[_a\x04\xDFa\x04\xDA\x84a\x04DV[a\x04*V[\x90P\x80\x83\x82R` \x82\x01\x90P` \x84\x02\x83\x01\x85\x81\x11\x15a\x05\x02Wa\x05\x01a\x04oV[[\x83[\x81\x81\x10\x15a\x05+W\x80a\x05\x17\x88\x82a\x04\xB9V[\x84R` \x84\x01\x93PP` \x81\x01\x90Pa\x05\x04V[PPP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a\x05IWa\x05Ha\x03\xB8V[[\x81Qa\x05Y\x84\x82` \x86\x01a\x04\xCDV[\x91PP\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x05wWa\x05va\x03\xB0V[[_\x82\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x05\x94Wa\x05\x93a\x03\xB4V[[a\x05\xA0\x84\x82\x85\x01a\x055V[\x91PP\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[a\x05\xDF\x81a\x04sV[\x81\x14a\x05\xE9W_\x80\xFD[PV[_\x81Q\x90Pa\x05\xFA\x81a\x05\xD6V[\x92\x91PPV[_\x81`\x02\x0B\x90P\x91\x90PV[a\x06\x15\x81a\x06\0V[\x81\x14a\x06\x1FW_\x80\xFD[PV[_\x81Q\x90Pa\x060\x81a\x06\x0CV[\x92\x91PPV[_a\xFF\xFF\x82\x16\x90P\x91\x90PV[a\x06L\x81a\x066V[\x81\x14a\x06VW_\x80\xFD[PV[_\x81Q\x90Pa\x06g\x81a\x06CV[\x92\x91PPV[_`\xFF\x82\x16\x90P\x91\x90PV[a\x06\x82\x81a\x06mV[\x81\x14a\x06\x8CW_\x80\xFD[PV[_\x81Q\x90Pa\x06\x9D\x81a\x06yV[\x92\x91PPV[_\x81\x15\x15\x90P\x91\x90PV[a\x06\xB7\x81a\x06\xA3V[\x81\x14a\x06\xC1W_\x80\xFD[PV[_\x81Q\x90Pa\x06\xD2\x81a\x06\xAEV[\x92\x91PPV[_\x80_\x80_\x80_`\xE0\x88\x8A\x03\x12\x15a\x06\xF3Wa\x06\xF2a\x03\xB0V[[_a\x07\0\x8A\x82\x8B\x01a\x05\xECV[\x97PP` a\x07\x11\x8A\x82\x8B\x01a\x06\"V[\x96PP`@a\x07\"\x8A\x82\x8B\x01a\x06YV[\x95PP``a\x073\x8A\x82\x8B\x01a\x06YV[\x94PP`\x80a\x07D\x8A\x82\x8B\x01a\x06YV[\x93PP`\xA0a\x07U\x8A\x82\x8B\x01a\x06\x8FV[\x92PP`\xC0a\x07f\x8A\x82\x8B\x01a\x06\xC4V[\x91PP\x92\x95\x98\x91\x94\x97P\x92\x95PV[a\x07~\x81a\x06\0V[\x82RPPV[_` \x82\x01\x90Pa\x07\x97_\x83\x01\x84a\x07uV[\x92\x91PPV[_o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a\x07\xC1\x81a\x07\x9DV[\x81\x14a\x07\xCBW_\x80\xFD[PV[_\x81Q\x90Pa\x07\xDC\x81a\x07\xB8V[\x92\x91PPV[_\x81`\x0F\x0B\x90P\x91\x90PV[a\x07\xF7\x81a\x07\xE2V[\x81\x14a\x08\x01W_\x80\xFD[PV[_\x81Q\x90Pa\x08\x12\x81a\x07\xEEV[\x92\x91PPV[_\x81\x90P\x91\x90PV[a\x08*\x81a\x08\x18V[\x81\x14a\x084W_\x80\xFD[PV[_\x81Q\x90Pa\x08E\x81a\x08!V[\x92\x91PPV[_\x81`\x06\x0B\x90P\x91\x90PV[a\x08`\x81a\x08KV[\x81\x14a\x08jW_\x80\xFD[PV[_\x81Q\x90Pa\x08{\x81a\x08WV[\x92\x91PPV[_c\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a\x08\x99\x81a\x08\x81V[\x81\x14a\x08\xA3W_\x80\xFD[PV[_\x81Q\x90Pa\x08\xB4\x81a\x08\x90V[\x92\x91PPV[_\x80_\x80_\x80_\x80a\x01\0\x89\x8B\x03\x12\x15a\x08\xD7Wa\x08\xD6a\x03\xB0V[[_a\x08\xE4\x8B\x82\x8C\x01a\x07\xCEV[\x98PP` a\x08\xF5\x8B\x82\x8C\x01a\x08\x04V[\x97PP`@a\t\x06\x8B\x82\x8C\x01a\x087V[\x96PP``a\t\x17\x8B\x82\x8C\x01a\x087V[\x95PP`\x80a\t(\x8B\x82\x8C\x01a\x08mV[\x94PP`\xA0a\t9\x8B\x82\x8C\x01a\x05\xECV[\x93PP`\xC0a\tJ\x8B\x82\x8C\x01a\x08\xA6V[\x92PP`\xE0a\t[\x8B\x82\x8C\x01a\x06\xC4V[\x91PP\x92\x95\x98P\x92\x95\x98\x90\x93\x96PV[_` \x82\x84\x03\x12\x15a\t\x80Wa\t\x7Fa\x03\xB0V[[_a\t\x8D\x84\x82\x85\x01a\x07\xCEV[\x91PP\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[a\t\xC8\x81a\x07\x9DV[\x82RPPV[a\t\xD7\x81a\x04sV[\x82RPPV[a\t\xE6\x81a\x06\0V[\x82RPPV[a\t\xF5\x81a\x07\xE2V[\x82RPPV[`\x80\x82\x01_\x82\x01Qa\n\x0F_\x85\x01\x82a\t\xBFV[P` \x82\x01Qa\n\"` \x85\x01\x82a\t\xCEV[P`@\x82\x01Qa\n5`@\x85\x01\x82a\t\xDDV[P``\x82\x01Qa\nH``\x85\x01\x82a\t\xECV[PPPPV[_a\nY\x83\x83a\t\xFBV[`\x80\x83\x01\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_a\n{\x82a\t\x96V[a\n\x85\x81\x85a\t\xA0V[\x93Pa\n\x90\x83a\t\xB0V[\x80_[\x83\x81\x10\x15a\n\xC0W\x81Qa\n\xA7\x88\x82a\nNV[\x97Pa\n\xB2\x83a\neV[\x92PP`\x01\x81\x01\x90Pa\n\x93V[P\x85\x93PPPP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra\n\xE5\x81\x84a\nqV[\x90P\x92\x91PPV\xFE",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040525f80fdfea26469706673582212203dc6f45a21a703987cf7f01fafa36e00f55c74c1525d7adece4bba075b7009e564736f6c634300081a0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R_\x80\xFD\xFE\xA2dipfsX\"\x12 =\xC6\xF4Z!\xA7\x03\x98|\xF7\xF0\x1F\xAF\xA3n\0\xF5\\t\xC1R]z\xDE\xCEK\xBA\x07[p\t\xE5dsolcC\0\x08\x1A\x003",
    );
    /**Constructor`.
```solidity
constructor(address[] pools);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct constructorCall {
        pub pools: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value.pools,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { pools: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.pools),
                )
            }
        }
    };
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`SyncUniswapV3PoolBatchRequest`](self) contract instance.

See the [wrapper's documentation](`SyncUniswapV3PoolBatchRequestInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> SyncUniswapV3PoolBatchRequestInstance<T, P, N> {
        SyncUniswapV3PoolBatchRequestInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        pools: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<SyncUniswapV3PoolBatchRequestInstance<T, P, N>>,
    > {
        SyncUniswapV3PoolBatchRequestInstance::<T, P, N>::deploy(provider, pools)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        pools: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        SyncUniswapV3PoolBatchRequestInstance::<T, P, N>::deploy_builder(provider, pools)
    }
    /**A [`SyncUniswapV3PoolBatchRequest`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`SyncUniswapV3PoolBatchRequest`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct SyncUniswapV3PoolBatchRequestInstance<
        T,
        P,
        N = alloy_contract::private::Ethereum,
    > {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for SyncUniswapV3PoolBatchRequestInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("SyncUniswapV3PoolBatchRequestInstance")
                .field(&self.address)
                .finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyncUniswapV3PoolBatchRequestInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`SyncUniswapV3PoolBatchRequest`](self) contract instance.

See the [wrapper's documentation](`SyncUniswapV3PoolBatchRequestInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            pools: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
        ) -> alloy_contract::Result<SyncUniswapV3PoolBatchRequestInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider, pools);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            pools: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall { pools },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> SyncUniswapV3PoolBatchRequestInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(
            self,
        ) -> SyncUniswapV3PoolBatchRequestInstance<T, P, N> {
            SyncUniswapV3PoolBatchRequestInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyncUniswapV3PoolBatchRequestInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyncUniswapV3PoolBatchRequestInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
